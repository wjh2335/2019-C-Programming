# 1. 퀵정렬에 대하여
## 1.1. 동작순서
```
1) 기준값을 하나 선택한다. 이 기준값을 pivot이라 한다.
2) pivot을 기준으로 pivot보다 작은 값은 pivot의 왼쪽, 큰 값은 pivot의 오른쪽에 배치한다.
3) pivot을 기준으로 나누어진 부분 배열에 대해 1), 2) 과정을 반복한다.
4) 부분 배열이 더 이상 분할이 불가능할 때까지 반복한다.
```
## 1.2. 시간복잡도
```
극단적인 두 상황만 보면
1) 피봇을 기준으로 나눌때 마다 반반씩 나누어지는 경우
2) 피봇과 나머지로 나누어지는 경우
두가지가 있습니다.
1번의 경우는 반반씩 나누어지므로 로그의 시간복잡도를 가지지만
2번의 경우는 N,(N-1),(N-2),...이므로 최악의 경우 N^2까지 걸릴수 있습니다.
```
# 2. 유튜브 링크
[유튜브 링크](https://www.youtube.com)
# 3. 소스코드
```c
#include <stdio.h>
void swap(int *a,int *b)
{
	int t;
	t=*a;
	*a=*b;
	*b=t;
}
int sort(int a[],int begin,int end)
{
	int pivot=(begin+end)/2,left=begin,right=end;
	while(left<right)
	{
		while(left<=right && a[left]<=a[pivot]) ++left;
		while(left<=right && a[right]>a[pivot]) --right;
		if(left<=right)
		{
			swap(&a[left],&a[right]);
			if(right==pivot) return left;
		}
	}
	swap(&a[right],&a[pivot]);
	return right;
}
void qs(int a[],int begin,int end)
{
	if(begin<end)
	{
		int p;
		p=sort(a,begin,end);
		qs(a,begin,p-1);
		qs(a,p+1,end);
	}
}
void main()
{
	int i,a[5]={3,1,5,2,4};
	qs(a,0,4);
	for(i=0;i<5;++i) printf("%d ", a[i]);
}
```
# 4. 소감
```
 지난 시간에 배운 퀵 정렬 알고리즘은 다른 원소와의 비교만으로 정렬을 행하는 비교 정렬에 속한다.
퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 작동하도록 설계되어 있고, 그 이유는
메모리 참조가 지역화되어 있기 때문에 CPU 캐시의 히트율이 높아지기 때문이다. 대부분의 실질적인
데이터를 정렬할 때 제곱 시간이 걸릴 확률이 거의 없도록 알고리즘을 설계하는 것이 가능하다. 또한 매
단계에서 적어도 1개의 원소가 자기 자리를 찾게 되므로 이후 정렬할 개수가 줄어든다. 때문에 일반적인
경우 퀵 정렬은 다른 알고리즘에 비해 훨씬 빠르게 작동한다. 퀵 정렬은 원소들 중에 같은 값이 있는
경우 같은 값들의 정렬 이후 순서가 초기 순서와 달라질 수 있어 불안정 정렬에 속한다. 단점은 피봇 값을
설정하는 것에 따라서 최악의 시간 복잡도가 제곱이 나올 정도로 특정한 경우에 있어서는 비효율적일 수
있다는 거다.

1학기때 배운 버블 쇼팅이 제일 효율적인 알고리즘이라고 생각했는데 더 효율적이고 쉬운 퀵
정렬을 배워서 흥미로웠습니다. 또 다음 시간엔 어떤 알고리즘을 배울지 매우 기대댑니다. 앞으로도 열심히
해서 C언어를 정복하고 싶습니다. C언어 사랑합니다!
```
