# 1. 퀵정렬 동작원리
```
1) 기준값을 하나 선택한다. 이 기준값을 pivot이라 한다.
2) pivot을 기준으로 pivot보다 작은 값은 pivot의 왼쪽, 큰 값은 pivot의 오른쪽에 배치한다.
3) pivot을 기준으로 나누어진 부분 배열에 대해 1), 2) 과정을 반복한다.
4) 부분 배열이 더 이상 분할이 불가능할 때까지 반복한다.
```
# 2. 유튜브 링크
[유튜브 링크](https://www.youtube.com)
# 3. 소스코드
```c
#include <stdio.h>
void swap(int *a,int *b)
{
	int t;
	t=*a;
	*a=*b;
	*b=t;
}
int sort(int a[],int begin,int end)
{
	int pivot=(begin+end)/2,left=begin,right=end;
	while(left<right)
	{
		while(left<=right && a[left]<=a[pivot]) ++left;
		while(left<=right && a[right]>a[pivot]) --right;
		if(left<=right)
		{
			swap(&a[left],&a[right]);
			if(right==pivot) return left;
		}
	}
	swap(&a[right],&a[pivot]);
	return right;
}
void qs(int a[],int begin,int end)
{
	if(begin<end)
	{
		int p;
		p=sort(a,begin,end);
		qs(a,begin,p-1);
		qs(a,p+1,end);
	}
}
void main()
{
	int i,a[5]={3,1,5,2,4};
	qs(a,0,4);
	for(i=0;i<5;++i) printf("%d ", a[i]);
}
```
